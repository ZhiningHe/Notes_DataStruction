数据结构_基本概念

---

**线性表**

1.线性表：

由n（n>0）个数据元素组成的有限序列，记作L，只有一个头节点，只有一个尾节点。

- 第i个元素存储位置是：loc（ai）= loc（a1）+（i-1）*L
- 顺序存储、随机存取
- 基本操作

```c
插入：
1.检查位置是否合法、表是否已满
2.寻找插入位置
3.插入位置后的元素均往后移动一位，插入元素，表长加一
//在表头插入-O（1）；在表尾插入-O（n）；
删除：
1.检查线性表是否为空、删除位置是否合法
2.寻找删除位置
3.将删除位置后的元素均向前移动一位，表长减一
//在表头删除-O（1）；在表尾删除-O（n）；
```

2.线性链表：

```c
单链表：
每个节点设有一个指针指向其后继节点。
单链表的存取必须从表头开始，在第一个节点前添加头节点，头节点不存储任何数据（有时会存储表的长度）。
//插入、删除的时间复杂度都是O（n）

循环链表：
单链表的最后一个节点的指针指向头节点。可以将任何一个节点作为头节点。

双链表：
除头节点和尾节点之外，每个节点都存在一个指向前驱结点的指针和指向后继节点的指针。
双链表也是由头节点确定的。

```

3.顺序表和链表的比较

```
1.存储
线性表可以动态分配内存；顺序表静态分配一定的内存；
2.时间效率
线性表存取O（n）；顺序表存取O（1）；
线性表对于插入删除操作比较高效；顺序表对于查找存取比较高效；
```



---

**栈和队列**

1.栈（LIFO）：

last in first out

```
限定仅在一端进行插入、删除、存取操作的线性表。
特点：后进先出

栈顶：允许插入的一端。
栈底：不允许插入的一端。
入栈：插入元素的操作。
出栈：取出元素的操作。
```

```c
顺序栈：
s->top==-1；表示栈空；
s->top==maxsize-1；表示栈满；//存在上溢现象

链栈：
从栈顶往下指，也就是说插入、存取都是从栈顶（链头）操作。
s->top==NULL；表示空栈；//不存在上溢现象

```

2.队列（FIFO）：

first in first out

```c
一端插入，一端取出的线性表。
特点：先进先出

入队：插入元素的操作。
出队：取出元素的操作。
```

```c
链队列：
头指针->头节点->队首……->队尾
尾指针->队尾
q->front==q->rear;队空；

顺序队：
rear始终指向队首，front始终指向队尾。
q->rear-q->front==max;队满；
q->rear==q->front;对空；
但是q->rear==max;不能再入队；//造成了空间浪费。

循环队列：
q->front==q->rear；队空/满
少用一个空间元素作为标志：
 q->front==q->rear；队空；
（q->rear+1）%max==q->front;队满；
```

---

**串和数组**

1.串

```
串的模式匹配（字串匹配）
复杂度O（m*n）
```

2.数组

```c
用二维数组来表示矩阵

特殊矩阵的压缩
1.对称矩阵
k={ i*(i+1)/2+j i>=j
    j*(j+1)/2+i i<j
    
2.三角矩阵
k={ i*(i+1)/2+j i>=j   //下三角
    n*(n+1)/2   i<j
k={ i*(2*n-i+1)/2+j-i i>=j   //上三角
    n*(n+1)/2         i<j
    
3.对角矩阵
k= 2+3*(i-1)+j-(i-1)= 2*i+j

4.稀疏矩阵
用三元组表示法、链式存储法

```

---

**树和二叉树**

1.树

```
树是一种非线性结构
树是由一个根节点和m(m>0)棵树组成的森林
```

2.二叉树

```c
二叉树是一种 度为2的 有序树  //即左右子树不可颠倒
    
满二叉树：所有分支度都为2的二叉树，且叶子节点都在同一层。
完全二叉树：编号可以和满二叉树的编号一一对应的二叉树。
//满二叉树本身就是一个完全二叉树

性质：
1.二叉树的第i层最多由2^(i-1)个节点（i>=1）
2.深度为k的二叉树最多有2^k-1个节点 （k>=1）
3.二叉树中，叶子节点数=度为2节点数+1
4.有n个节点的完全二叉树的深度是log2（n）+1
```

3.二叉树、树和森林之间的转换

```
1.树->二叉树
 ①加线 在兄弟节点之间加一虚线
 ②抹线 每一个节点除了最左一个孩子外，抹掉与其余孩子的线
 ③旋转 将原有实线的向左，加虚线的向右
 //特点：根节点没有右子树，左孩子右兄弟
 
2.二叉树->树
 按照左孩子右兄弟排好
 
3.森林->二叉树
 ①将森林中各树转化成二叉树
 ②按照森林中的次序将后一个二叉树作为前一个二叉树的右节点
 //左孩子右兄弟
 
4.二叉树->森林
 原路返回
```

4.二叉树遍历

```
前序遍历 根左右
中序遍历 左根右
后序遍历 左右根
```

5.树的应用

```
1.哈夫曼树
树的路径长度（PL）：从树根到每一个节点的路径长度之和。
哈夫曼树（最优树）：带权路径（WPL）最小二叉树。

算法：
①选择权重最小的二叉树作为左右子树，设置新二叉树的权值为左右权值之和。
②然后在集合中删除这两颗树，将新生成的树加入集合。
③重复①②步直到集合中剩下一棵树为止。
 
2.哈夫曼编码
按照权值构造哈夫曼树，左0右1来构造哈夫曼编码。
```

